 ##################
 lambda expressions
 ##################

 lambda expressions
 ==================

 A lambda expression is, essentially, an anonymous (that is, unnamed) method.
 However, this method is not executed on its own.

 A functional interface is an interface that contains one and only one 
 abstract method.

 A fucntional interface defines the target type of a lambda expression
 A lambda expression can be used only in a context in which its
 target type is specified.

 Lambda operator "->" divides a lambda expression into two parts.
 The left side specifies any paramters required by the lambda
 expression (may be empty). On the right side is the lambda body,
 which specified the actions of the lambda expression.

 There are two types of lambda bodies.
 One consists of a single expression,
 and the other type consists of a block of code.

 The lambda expression must be compatible with the abstract
 method it is intented to implement.

 Lambda expressions can be used in assignment contexts.
 One of these contexts is created when a lambda expression is assigned
 to a functional interface reference.

 Other target type contexts include variable initialization,
 return statements, and method arguments.

 Another context is when lambda expression is passed as an argument.

 In addition to variable initialization, assignment, and argument passing,
 the following also constitute target type contexts: casts, the "?" operator
 array initializers, "return" statements, and lambda expresions, themselves.


 variable capture
 ================

 Variables defined by the enclosing scope of a lambda expression are accessible
 whithin the lambda expresion.
 However, when a lambda expression uses a local variable from its enclosing scope, a
 special situation is created that is referred to as a variable capture. In this case, a lambda
 expression may only use local variables that are effectively final. An effectively final variable is
 one whose value does not change after it is first assigned. There is no need to explicitly
 declare such a variable as final, although doing so would not be an error. (The this
 parameter of an enclosing scope is automatically effectively final, and lambda expressions
 do not have a this of their own.)

 It is important to emphasize that a lambda expression can use and modify an instance
 variable from its invoking class. It just can’t use a local variable of its enclosing scope unless
 that variable is effectively final.